# DMA System

<details>
<summary>Relevant source files</summary>

The following files were used as context for generating this wiki page:

- [Core/Inc/dma.h](Core/Inc/dma.h)
- [Core/Src/adc.c](Core/Src/adc.c)
- [Core/Src/dma.c](Core/Src/dma.c)
- [Core/Src/usart.c](Core/Src/usart.c)

</details>



## Purpose and Scope

This page documents the Direct Memory Access (DMA) controllers and their configuration in the STM32-TFTLCD-UI system. The DMA subsystem enables autonomous data transfer between peripherals and memory without CPU intervention, reducing processor load and enabling efficient real-time operation.

The system uses two DMA controllers:
- **DMA1**: Handles USART1 serial communication transfers
- **DMA2**: Handles ADC3 light sensor data acquisition

For information about the peripherals that use DMA, see [ADC and Light Sensor](#4.2) and [Serial Communication (USART)](#4.6). For interrupt handling details, see [Interrupt System](#3.3).

**Sources: ** [Core/Src/dma.c:1-63](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/dma.c#L1-L63), [Core/Inc/dma.h:1-53](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Inc/dma.h#L1-L53)

---

## DMA Controller Architecture

The STM32F1xx microcontroller provides two DMA controllers with multiple channels. Each channel is dedicated to servicing specific peripheral requests.

### DMA Controller and Channel Assignment

```mermaid
graph TB
    subgraph DMA1["DMA1 Controller"]
        DMA1_CH4["DMA1 Channel 4<br/>USART1 TX"]
        DMA1_CH5["DMA1 Channel 5<br/>USART1 RX"]
    end
    
    subgraph DMA2["DMA2 Controller"]
        DMA2_CH5["DMA2 Channel 5<br/>ADC3"]
    end
    
    subgraph Peripherals["Hardware Peripherals"]
        USART1_TX["USART1 Transmitter"]
        USART1_RX["USART1 Receiver"]
        ADC3["ADC3 Converter"]
    end
    
    subgraph Memory["System Memory"]
        TX_BUF["UART TX Buffer"]
        RX_BUF["UART RX Buffer"]
        ADC_BUF["adc_val Buffer"]
    end
    
    TX_BUF -->|"Memory to Peripheral"| DMA1_CH4
    DMA1_CH4 -->|"Serial Data"| USART1_TX
    
    USART1_RX -->|"Serial Data"| DMA1_CH5
    DMA1_CH5 -->|"Peripheral to Memory"| RX_BUF
    
    ADC3 -->|"Conversion Data"| DMA2_CH5
    DMA2_CH5 -->|"Peripheral to Memory"| ADC_BUF
```

**DMA Controller and Channel Assignments**

| Controller | Channel | Peripheral | Direction | Transfer Mode | Data Size |
|------------|---------|------------|-----------|---------------|-----------|
| DMA1 | Channel 4 | USART1_TX | Memory → Peripheral | Normal | 8-bit (byte) |
| DMA1 | Channel 5 | USART1_RX | Peripheral → Memory | Normal | 8-bit (byte) |
| DMA2 | Channel 5 | ADC3 | Peripheral → Memory | Circular | 16-bit (halfword) |

**Sources: ** [Core/Src/dma.c:39-57](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/dma.c#L39-L57), [Core/Src/adc.c:93-108](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L93-L108), [Core/Src/usart.c:88-119](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L88-L119)

---

## System Initialization

The DMA system is initialized early in the system startup sequence, before peripheral initialization. This ensures DMA channels are ready when peripherals that depend on them are configured.

### Initialization Sequence

```mermaid
sequenceDiagram
    participant Main as main()
    participant DMA_Init as MX_DMA_Init()
    participant RCC as RCC Peripheral
    participant NVIC as NVIC Controller
    participant ADC_Init as MX_ADC3_Init()
    participant UART_Init as MX_USART1_UART_Init()
    
    Main->>DMA_Init: Initialize DMA
    DMA_Init->>RCC: __HAL_RCC_DMA1_CLK_ENABLE()
    DMA_Init->>RCC: __HAL_RCC_DMA2_CLK_ENABLE()
    DMA_Init->>NVIC: Configure DMA1_Channel4_IRQn
    DMA_Init->>NVIC: Configure DMA1_Channel5_IRQn
    DMA_Init->>NVIC: Configure DMA2_Channel4_5_IRQn
    DMA_Init-->>Main: Return
    
    Main->>ADC_Init: Initialize ADC3
    ADC_Init->>ADC_Init: Configure DMA2_Channel5
    ADC_Init->>ADC_Init: Link DMA to hadc3
    
    Main->>UART_Init: Initialize USART1
    UART_Init->>UART_Init: Configure DMA1_Channel4
    UART_Init->>UART_Init: Configure DMA1_Channel5
    UART_Init->>UART_Init: Link DMA to huart1
```

### MX_DMA_Init Function

The `MX_DMA_Init()` function performs global DMA controller initialization:

1. **Clock Enable**: Enables peripheral clocks for both DMA1 and DMA2 controllers
2. **Interrupt Configuration**: Configures NVIC interrupt priorities for all used DMA channels
3. **Priority Setting**: All DMA interrupts are set to priority group 0, sub-priority 0 (highest priority)

```c
// Simplified view of MX_DMA_Init implementation
void MX_DMA_Init(void)
{
    __HAL_RCC_DMA1_CLK_ENABLE();
    __HAL_RCC_DMA2_CLK_ENABLE();
    
    HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
    
    HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
    
    HAL_NVIC_SetPriority(DMA2_Channel4_5_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
}
```

**Sources: ** [Core/Src/dma.c:39-57](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/dma.c#L39-L57)

---

## DMA Channel Configurations

Each DMA channel is configured with specific parameters tailored to its peripheral requirements.

### ADC3 DMA Configuration (DMA2 Channel 5)

The ADC3 uses DMA for continuous acquisition of light sensor readings without CPU intervention.

**Configuration Parameters:**

| Parameter | Value | Purpose |
|-----------|-------|---------|
| `Instance` | `DMA2_Channel5` | Hardware channel assignment |
| `Direction` | `DMA_PERIPH_TO_MEMORY` | ADC data flows to memory buffer |
| `PeriphInc` | `DMA_PINC_DISABLE` | ADC data register address is fixed |
| `MemInc` | `DMA_MINC_ENABLE` | Memory buffer address increments |
| `PeriphDataAlignment` | `DMA_PDATAALIGN_HALFWORD` | 16-bit ADC conversion result |
| `MemDataAlignment` | `DMA_MDATAALIGN_HALFWORD` | 16-bit storage in memory |
| `Mode` | `DMA_CIRCULAR` | Continuous acquisition with buffer wrap-around |
| `Priority` | `DMA_PRIORITY_LOW` | Non-critical background operation |

**Circular Mode Operation:**

In circular mode, the DMA automatically wraps back to the beginning of the buffer after reaching the end, enabling continuous data acquisition without CPU intervention. This is ideal for the light sensor, which requires periodic sampling.

```mermaid
graph LR
    ADC3["ADC3 Data Register<br/>Fixed Address"] -->|"16-bit Halfword"| DMA2_CH5["DMA2 Channel 5<br/>Circular Transfer"]
    DMA2_CH5 -->|"Auto-increment"| BUF_START["adc_val[0]"]
    BUF_START --> BUF_MIDDLE["adc_val[...]"]
    BUF_MIDDLE --> BUF_END["adc_val[N-1]"]
    BUF_END -.->|"Wrap Around"| BUF_START
```

**Handle Structure:**

```c
// From adc.c
DMA_HandleTypeDef hdma_adc3;

hdma_adc3.Instance = DMA2_Channel5;
hdma_adc3.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_adc3.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_adc3.Init.MemInc = DMA_MINC_ENABLE;
hdma_adc3.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
hdma_adc3.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
hdma_adc3.Init.Mode = DMA_CIRCULAR;
hdma_adc3.Init.Priority = DMA_PRIORITY_LOW;
```

**DMA Linkage:**

The DMA channel is linked to the ADC handle using the `__HAL_LINKDMA` macro, establishing the connection between the peripheral and its DMA channel.

```c
__HAL_LINKDMA(adcHandle, DMA_Handle, hdma_adc3);
```

**Sources: ** [Core/Src/adc.c:93-108](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L93-L108)

### USART1 DMA Configuration (DMA1 Channels 4 and 5)

USART1 uses two DMA channels for bidirectional serial communication: one for transmission and one for reception.

#### USART1 TX - DMA1 Channel 4

**Configuration Parameters:**

| Parameter | Value | Purpose |
|-----------|-------|---------|
| `Instance` | `DMA1_Channel4` | Hardware channel assignment |
| `Direction` | `DMA_MEMORY_TO_PERIPH` | Transmit buffer flows to USART |
| `PeriphInc` | `DMA_PINC_DISABLE` | USART data register address is fixed |
| `MemInc` | `DMA_MINC_ENABLE` | Transmit buffer address increments |
| `PeriphDataAlignment` | `DMA_PDATAALIGN_BYTE` | 8-bit serial character |
| `MemDataAlignment` | `DMA_MDATAALIGN_BYTE` | 8-bit storage in memory |
| `Mode` | `DMA_NORMAL` | One-shot transfer per transmit request |
| `Priority` | `DMA_PRIORITY_LOW` | Non-critical background operation |

#### USART1 RX - DMA1 Channel 5

**Configuration Parameters:**

| Parameter | Value | Purpose |
|-----------|-------|---------|
| `Instance` | `DMA1_Channel5` | Hardware channel assignment |
| `Direction` | `DMA_PERIPH_TO_MEMORY` | USART data flows to receive buffer |
| `PeriphInc` | `DMA_PINC_DISABLE` | USART data register address is fixed |
| `MemInc` | `DMA_MINC_ENABLE` | Receive buffer address increments |
| `PeriphDataAlignment` | `DMA_PDATAALIGN_BYTE` | 8-bit serial character |
| `MemDataAlignment` | `DMA_MDATAALIGN_BYTE` | 8-bit storage in memory |
| `Mode` | `DMA_NORMAL` | One-shot transfer per receive request |
| `Priority` | `DMA_PRIORITY_LOW` | Non-critical background operation |

**Normal Mode Operation:**

In normal mode, the DMA performs a single transfer from start address to end address, then stops. The application must restart the transfer for subsequent operations. This is appropriate for USART, where each message has a defined length.

```mermaid
graph LR
    subgraph TX["Transmission Path"]
        TX_MEM["TX Buffer<br/>Memory"] -->|"Byte Stream"| DMA1_CH4["DMA1 Channel 4<br/>Normal Mode"]
        DMA1_CH4 -->|"8-bit Bytes"| USART_TX["USART1 TX Register"]
        USART_TX -->|"Serial Line"| EXTERNAL_TX["External Device"]
    end
    
    subgraph RX["Reception Path"]
        EXTERNAL_RX["External Device"] -->|"Serial Line"| USART_RX["USART1 RX Register"]
        USART_RX -->|"8-bit Bytes"| DMA1_CH5["DMA1 Channel 5<br/>Normal Mode"]
        DMA1_CH5 -->|"Byte Stream"| RX_MEM["RX Buffer<br/>Memory"]
    end
```

**Handle Structures:**

```c
// From usart.c
DMA_HandleTypeDef hdma_usart1_rx;
DMA_HandleTypeDef hdma_usart1_tx;

// TX configuration
hdma_usart1_tx.Instance = DMA1_Channel4;
hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart1_tx.Init.Mode = DMA_NORMAL;
hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;

// RX configuration
hdma_usart1_rx.Instance = DMA1_Channel5;
hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
// ... (similar parameters)
```

**DMA Linkage:**

Both channels are linked to the UART handle:

```c
__HAL_LINKDMA(uartHandle, hdmarx, hdma_usart1_rx);
__HAL_LINKDMA(uartHandle, hdmatx, hdma_usart1_tx);
```

**Sources: ** [Core/Src/usart.c:88-119](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L88-L119)

---

## DMA Transfer Modes Comparison

The system uses two different DMA transfer modes depending on peripheral requirements:

| Feature | Circular Mode | Normal Mode |
|---------|---------------|-------------|
| **Used By** | ADC3 (DMA2_CH5) | USART1 TX/RX (DMA1_CH4/5) |
| **Buffer Handling** | Automatic wrap-around | Stops at end |
| **Restart Required** | No (continuous) | Yes (per transfer) |
| **Use Case** | Continuous sampling | Message-based communication |
| **CPU Intervention** | Minimal (only for reading data) | Required between transfers |
| **Ideal For** | Periodic sensor acquisition | Event-driven communication |

### Circular Mode Data Flow (ADC3)

```mermaid
sequenceDiagram
    participant ADC as ADC3 Peripheral
    participant DMA as DMA2 Channel 5
    participant Buffer as adc_val Buffer
    participant App as automode_task
    
    Note over DMA: Circular Mode Active
    
    loop Continuous Conversion
        ADC->>DMA: Conversion Complete
        DMA->>Buffer: Write to Buffer[i]
        DMA->>DMA: Increment Address
        
        alt Buffer End Reached
            DMA->>DMA: Wrap to Buffer[0]
        end
    end
    
    App->>Buffer: Read Latest Value
    Note over App: No DMA restart needed
```

### Normal Mode Data Flow (USART1)

```mermaid
sequenceDiagram
    participant App as Application
    participant HAL as HAL_UART_Transmit_DMA
    participant DMA as DMA1 Channel 4
    participant UART as USART1 Peripheral
    
    Note over DMA: Normal Mode
    
    App->>HAL: HAL_UART_Transmit_DMA(data, len)
    HAL->>DMA: Configure Transfer
    HAL->>DMA: Start Transfer
    
    loop Until Transfer Complete
        UART->>DMA: Request Data
        DMA->>UART: Send Byte
        DMA->>DMA: Increment Address
    end
    
    DMA->>DMA: Stop (End Reached)
    DMA->>HAL: Transfer Complete Interrupt
    HAL->>App: Callback Notification
    
    Note over App: Must call HAL function<br/>for next transfer
```

**Sources: ** [Core/Src/adc.c:93-108](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L93-L108), [Core/Src/usart.c:88-119](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L88-L119)

---

## DMA Interrupt Configuration

All DMA channels are configured with interrupt support to notify the system when transfers complete or errors occur.

### Interrupt Vector Configuration

| Interrupt Vector | DMA Channels Served | Priority | Sub-Priority | Purpose |
|-----------------|---------------------|----------|--------------|---------|
| `DMA1_Channel4_IRQn` | DMA1 Channel 4 (USART1 TX) | 0 | 0 | TX transfer complete/error |
| `DMA1_Channel5_IRQn` | DMA1 Channel 5 (USART1 RX) | 0 | 0 | RX transfer complete/error |
| `DMA2_Channel4_5_IRQn` | DMA2 Channels 4 & 5 (ADC3) | 0 | 0 | ADC transfer complete/error |

**Note:** Priority 0 is the highest priority level. All DMA interrupts share the same priority, meaning they are serviced in the order they occur.

### Interrupt Processing Flow

```mermaid
graph TB
    HW_EVENT["Hardware Event<br/>(Transfer Complete)"] -->|"Triggers"| NVIC["NVIC"]
    NVIC -->|"Vector Table"| ISR["DMA IRQ Handler<br/>(stm32f1xx_it.c)"]
    ISR -->|"Calls"| HAL_DMA["HAL_DMA_IRQHandler()"]
    
    HAL_DMA -->|"Checks Flags"| FLAGS{{"Transfer<br/>Complete?"}}
    FLAGS -->|"Yes"| TC_CB["Transfer Complete<br/>Callback"]
    FLAGS -->|"Error"| ERR_CB["Transfer Error<br/>Callback"]
    
    TC_CB -->|"Peripheral-Specific"| PERIPH_CB["HAL Peripheral Callback<br/>(e.g., HAL_ADC_ConvCpltCallback)"]
    
    PERIPH_CB -->|"If Defined"| USER_CB["User Application<br/>Callback Function"]
```

**Interrupt Service Routine Structure:**

The interrupt handlers follow the HAL pattern:

1. **Hardware ISR** (in `stm32f1xx_it.c`): Minimal wrapper that calls HAL
2. **HAL Handler** (`HAL_DMA_IRQHandler`): Checks flags and dispatches to callbacks
3. **Peripheral Callbacks**: HAL-level callbacks for specific peripherals
4. **User Callbacks**: Application-specific callback functions (weak, can be overridden)

**Sources: ** [Core/Src/dma.c:46-56](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/dma.c#L46-L56), [Core/Src/adc.c:110-112](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L110-L112), [Core/Src/usart.c:121-123](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L121-L123)

---

## Integration with Peripherals

DMA channels are tightly integrated with their associated peripherals through HAL handle linkage and peripheral-specific initialization.

### Peripheral-DMA Linkage Mechanism

```mermaid
graph TB
    subgraph ADC_MSP["HAL_ADC_MspInit()"]
        ADC_CREATE["Create hdma_adc3<br/>DMA_HandleTypeDef"]
        ADC_CONFIG["Configure DMA Parameters<br/>(Circular, Halfword)"]
        ADC_INIT["HAL_DMA_Init(&hdma_adc3)"]
        ADC_LINK["__HAL_LINKDMA(hadc3,<br/>DMA_Handle, hdma_adc3)"]
    end
    
    subgraph UART_MSP["HAL_UART_MspInit()"]
        UART_CREATE_TX["Create hdma_usart1_tx<br/>DMA_HandleTypeDef"]
        UART_CONFIG_TX["Configure TX Parameters<br/>(Normal, Byte)"]
        UART_INIT_TX["HAL_DMA_Init(&hdma_usart1_tx)"]
        UART_LINK_TX["__HAL_LINKDMA(huart1,<br/>hdmatx, hdma_usart1_tx)"]
        
        UART_CREATE_RX["Create hdma_usart1_rx<br/>DMA_HandleTypeDef"]
        UART_CONFIG_RX["Configure RX Parameters<br/>(Normal, Byte)"]
        UART_INIT_RX["HAL_DMA_Init(&hdma_usart1_rx)"]
        UART_LINK_RX["__HAL_LINKDMA(huart1,<br/>hdmarx, hdma_usart1_rx)"]
    end
    
    ADC_CREATE --> ADC_CONFIG
    ADC_CONFIG --> ADC_INIT
    ADC_INIT --> ADC_LINK
    
    UART_CREATE_TX --> UART_CONFIG_TX
    UART_CONFIG_TX --> UART_INIT_TX
    UART_INIT_TX --> UART_LINK_TX
    
    UART_CREATE_RX --> UART_CONFIG_RX
    UART_CONFIG_RX --> UART_INIT_RX
    UART_INIT_RX --> UART_LINK_RX
```

### Complete Data Flow: Light Sensor to Application

This diagram shows the complete autonomous data path from the physical light sensor to the application, demonstrating how DMA eliminates CPU involvement in data transfer.

```mermaid
graph TB
    SENSOR["Light Sensor<br/>(Photoresistor)"] -->|"Analog Voltage"| ADC_INPUT["ADC3 Channel 6<br/>PF8 GPIO Pin"]
    ADC_INPUT -->|"Analog Signal"| ADC_CONV["ADC3 Converter<br/>12-bit Conversion"]
    ADC_CONV -->|"Digital Value"| ADC_DR["ADC3 Data Register<br/>Fixed Address"]
    
    ADC_DR -->|"DMA Request"| DMA_CTRL["DMA2 Channel 5<br/>Circular Mode"]
    DMA_CTRL -->|"Automatic Transfer"| MEM_BUF["adc_val Buffer<br/>System RAM"]
    
    MEM_BUF -->|"Direct Read"| APP_TASK["automode_task()<br/>Application"]
    
    APP_TASK -->|"Compare Threshold"| LCD_CTRL["LCD Brightness<br/>Control"]
    
    Note_CPU["CPU Not Involved<br/>in Data Transfer"] -.-> DMA_CTRL
```

### DMA Request Flow

```mermaid
sequenceDiagram
    participant Periph as Peripheral (ADC3/USART1)
    participant DMA_Ctrl as DMA Controller
    participant Bus as AHB Bus
    participant Memory as System Memory
    
    Periph->>DMA_Ctrl: DMA Request Signal
    DMA_Ctrl->>Bus: Arbitration Request
    Bus->>DMA_Ctrl: Bus Granted
    
    alt Peripheral to Memory
        DMA_Ctrl->>Periph: Read Peripheral Register
        Periph->>DMA_Ctrl: Data
        DMA_Ctrl->>Memory: Write to Memory Address
    else Memory to Peripheral
        DMA_Ctrl->>Memory: Read Memory Address
        Memory->>DMA_Ctrl: Data
        DMA_Ctrl->>Periph: Write Peripheral Register
    end
    
    DMA_Ctrl->>DMA_Ctrl: Decrement Transfer Count
    
    alt Transfer Complete
        DMA_Ctrl->>DMA_Ctrl: Set Transfer Complete Flag
        DMA_Ctrl->>NVIC: Trigger Interrupt
    end
```

**Sources: ** [Core/Src/adc.c:73-117](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L73-L117), [Core/Src/usart.c:61-127](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L61-L127)

---

## Key DMA Handle Variables

The following global handle variables manage DMA channels throughout the system:

| Variable | Type | Scope | Purpose | Defined In |
|----------|------|-------|---------|-----------|
| `hdma_adc3` | `DMA_HandleTypeDef` | Global | ADC3 DMA transfer management | [Core/Src/adc.c:28]() |
| `hdma_usart1_rx` | `DMA_HandleTypeDef` | Global | USART1 receive DMA management | [Core/Src/usart.c:28]() |
| `hdma_usart1_tx` | `DMA_HandleTypeDef` | Global | USART1 transmit DMA management | [Core/Src/usart.c:29]() |

These handles are initialized in their respective peripheral MSP (MCU Support Package) initialization functions and linked to peripheral handles for coordinated operation.

**Sources: ** [Core/Src/adc.c:28](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L28), [Core/Src/usart.c:28-29](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L28-L29)

---

## Summary

The DMA system in STM32-TFTLCD-UI provides efficient, autonomous data transfer for two critical peripherals:

1. **ADC3 Light Sensor** (DMA2 Channel 5): Continuous circular-mode acquisition for ambient light monitoring
2. **USART1 Serial Port** (DMA1 Channels 4 & 5): Bidirectional normal-mode transfers for debug communication

**Key Design Characteristics:**

- **Minimal CPU Overhead**: DMA handles all data movement autonomously
- **Interrupt-Driven Completion**: High-priority interrupts notify completion without polling
- **Mode-Appropriate Configuration**: Circular mode for continuous sampling, normal mode for message-based communication
- **HAL Integration**: Standard STM32 HAL patterns for portability and maintainability
- **Early Initialization**: DMA controllers initialized before dependent peripherals

The DMA system enables the real-time application to maintain responsive UI updates and time-critical tasks while background data acquisition and communication proceed autonomously.

**Sources: ** [Core/Src/dma.c:1-63](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/dma.c#L1-L63), [Core/Src/adc.c:73-117](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/adc.c#L73-L117), [Core/Src/usart.c:61-127](https://github.com/BA2F/STM32-TFTLCD-UI/blob/e0f407ee/Core/Src/usart.c#L61-L127)